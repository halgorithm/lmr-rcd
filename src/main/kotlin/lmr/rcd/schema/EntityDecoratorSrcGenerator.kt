package lmr.rcd.schema

import lmr.rcd.models.entity.ParamSpec
import lmr.rcd.models.entity.ParamSpec.ParamType.NUMBER
import java.io.File
import java.nio.file.Path
import java.nio.file.Paths


class DecoratorSrcFileGenerator(
        private val def: EntityDecoratorDef
) {
    private val entityTypeName get() = if (def.isActor) "Actor" else "Effect"
    private val entityVariableName get() = if (def.isActor) "actor" else "effect"

    fun generateToDir(outputDirPath: Path) {
        val outputDir = File(outputDirPath.toString())
        val outputFilePath = Paths.get(outputDir.toString(), "${def.className}.kt")
        // TODO: throw exception if a file already exists at outputFilePath

        val classSrc = generate(true)

        if (!outputDir.exists()) outputDir.mkdirs()
        File(outputFilePath.toString()).writeText(classSrc)
    }



    private fun generate(addDisclaimerComment: Boolean = false): String {
        val disclaimer = if (addDisclaimerComment) "// This class file was generated by ${this::class.simpleName}\n" else ""

        val paramChoiceEnumDefsSrc = def.paramChoiceEnumDefs.joinToString("\n\n") {
            ParamChoiceEnumSrcGenerator(it).generateSrc()
        }

        val paramAccessorsSrc = def.paramSpecs.joinToString("\n") {
            val enumInfo = def.enumInfoByParamSpecName.getOrDefault(it.name, null)
            if (enumInfo == null) generateParamAccessorSrc(it)
            else generateEnumParamAccessorSrc(it, enumInfo.first)
        }

        return (
"""${disclaimer}package lmr.rcd.catalog.${entityVariableName}s

import lmr.rcd.models.decorators.*
import lmr.rcd.models.entity.ParamSpec
import lmr.rcd.models.entity.ParamSpec.ParamType
import lmr.rcd.models.entity.ParamSpec.ParamType.*
import lmr.rcd.models.entity.$entityTypeName
import lmr.rcd.catalog.enums.*

class ${def.className}
    @JvmOverloads constructor(
        $entityVariableName: $entityTypeName = generateDefault$entityTypeName()
    )
: ${entityTypeName}Decorator($entityVariableName) {

${generateParamSpecsEnumSrc(def.paramSpecs).toDepth(1)}

${paramChoiceEnumDefsSrc.toDepth(1)}

${paramAccessorsSrc.toDepth(1)}

    override fun toDebugString() = toDebugString(TYPE_ID, Param.values())
    override fun copy(): ${def.className} = wrap($entityVariableName.copy())

${generateDecoratorCompanionSrc().toDepth(1)}
}"""
        )
    }



    private fun generateParamSpecsEnumSrc(paramSpecs: List<ParamSpec>): String {
        val paramChoiceEnumDefsByName = def.paramChoiceEnumDefs.associateBy { it.enumName }

        val itemSrcs = paramSpecs.map {
            val enumInfo = def.enumInfoByParamSpecName.getOrDefault(it.name, null)
            if (enumInfo == null) generateParamSpecItemSrc(it)
            else generateEnumParamSpecItemSrc(it, enumInfo.first, enumInfo.second)
        }
        val allItemsSrc = itemSrcs.joinToString(",\n")

        return (
"""enum class Param(
    override val idx: Int,
    override val defaultValue: Short,
    override val validValueRanges: List<IntRange> = listOf(Short.MIN_VALUE..Short.MAX_VALUE),
    override val type: ParamType = NUMBER
) : ParamSpec {
${allItemsSrc.toDepth(1)};
}"""
        )
    }



    private fun generateParamSpecItemSrc(paramSpec: ParamSpec): String {
        // FIXME have enum types use MyType.SOMETHING.value for defaultValue and MyType.valueRanges for validValueRanges
        val ranges = paramSpec.validValueRanges
        val isFullRange = ranges.first() == Short.MIN_VALUE..Short.MAX_VALUE

        var trailingArgsStr =
            if (isFullRange)
                if (paramSpec.type == NUMBER)
                    ""
                else
                    "type = ${paramSpec.type.name}"
            else {
                val rangesStr = "listOf(${ranges.joinToString(", ") { "${it.first}..${it.last}" }})"
                "$rangesStr${if (paramSpec.type == NUMBER) "" else ", ${paramSpec.type.name}"}"
            }

        if (trailingArgsStr.isNotEmpty()) trailingArgsStr = ", $trailingArgsStr"

        return "${paramSpec.name}(${paramSpec.idx}, ${paramSpec.defaultValue}$trailingArgsStr)"
    }



    private fun generateEnumParamSpecItemSrc(paramSpec: ParamSpec, enumName: String, defaultItemName: String): String {
        val defaultValueStr = "$enumName.$defaultItemName.value"
        return "${paramSpec.name}(${paramSpec.idx}, $defaultValueStr, $enumName.valueRanges, ENUM)"
    }



    private fun generateParamAccessorSrc(paramSpec: ParamSpec): String {
        val delegateStr = "${getAccessorDelegateLeadingPart(paramSpec)})"
        return "var ${getAccessorName(paramSpec)} by $delegateStr"
    }



    private fun generateEnumParamAccessorSrc(paramSpec: ParamSpec, enumName: String): String {
        val delegateStr = "${getAccessorDelegateLeadingPart(paramSpec)}, $enumName)"
        return "var ${getAccessorName(paramSpec)} by $delegateStr"
    }



    private fun generateDecoratorCompanionSrc(): String =
"""companion object Static : ${entityTypeName}DecoratorCompanion<${def.className}, Param>
    (typeId = ${def.typeId}, paramSpecs = Param.values())
{
    const val TYPE_ID: Short = ${def.typeId}

    @JvmStatic override fun wrap($entityVariableName: $entityTypeName) = ${def.className}($entityVariableName)
}"""



    private fun getAccessorName(paramSpec: ParamSpec) = paramSpec.name.toPascalCase().decapitalize()
    private fun getAccessorDelegateLeadingPart(paramSpec: ParamSpec) =
        "${paramSpec.type.toString().toLowerCase().capitalize()}ParamAccessor(Param.${paramSpec.name}"
}



fun String.toDepth(depth: Int): String = prependIndent("    ".repeat(depth))

fun String.toPascalCase(): String {
    val sb = StringBuilder()

    for (token in toLowerCase().split("_")) {
        sb.append(token.capitalize())
    }

    return sb.toString()
}
